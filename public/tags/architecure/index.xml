<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecure on Sebiwi</title>
    <link>http://localhost:1313/tags/architecure/</link>
    <description>Recent content in Architecure on Sebiwi</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Sep 2017 20:19:02 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/architecure/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How does it work? Docker! Episode 3 - Swarm load balancing, service discovery and security</title>
      <link>http://localhost:1313/blog/how-does-it-work-docker-episode-3-swarm-load-balancing-service-discovery-and-security/</link>
      <pubDate>Thu, 21 Sep 2017 20:19:02 +0100</pubDate>
      <guid>http://localhost:1313/blog/how-does-it-work-docker-episode-3-swarm-load-balancing-service-discovery-and-security/</guid>
      <description>&lt;h2 id=&#34;why-service-discovery&#34;&gt;Why Service Discovery?&lt;/h2&gt;&#xA;&lt;p&gt;Right, Service Discovery. &lt;a href=&#34;https://sebiwi.github.io/blog/how-does-it-work-kube-2/&#34;&gt;From a previous article&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;“...What if your application needs to advertise its own IP address to&#xA;a container that is hosted on another node? It doesn’t actually knows&#xA;its real IP, since his local IP is getting translated into another IP&#xA;and a port on the host machine. ”&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;That’s why&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The Docker Engine has an embedded DNS server within it, which is used by&#xA;containers when Docker is not running in Swarm mode, and for tasks, when it is.&#xA;It provides name resolution to all the containers that are on the host in&#xA;bridge, overlay or MACVLAN networks. Each container forwards its queries to the&#xA;Docker Engine, which in turn checks if the container or service is on the same&#xA;network as the container that sent the request in the first place. If it is, it&#xA;searches the IP (or virtual IP) address that matches a container, a task’s or a&#xA;service’s name in its internal key-value store and returns it to the container&#xA;that sent the request. Pretty cool, huh?&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does it work? Docker! Episode 2 - Swarm networking</title>
      <link>http://localhost:1313/blog/how-does-it-work-docker-episode-2-swarm-networking/</link>
      <pubDate>Mon, 04 Sep 2017 20:19:02 +0100</pubDate>
      <guid>http://localhost:1313/blog/how-does-it-work-docker-episode-2-swarm-networking/</guid>
      <description>&lt;h2 id=&#34;so-what-about-networking-then&#34;&gt;So what about networking then?&lt;/h2&gt;&#xA;&lt;p&gt;Right, networking. From a &lt;a href=&#34;https://sebiwi.github.io/blog/how-does-it-work-kube-2/&#34;&gt;previous article on Kubernetes&#xA;Networking&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;“For each container that is created, a virtual ethernet device is&#xA;attached to this bridge, which is then mapped to eth0 inside the&#xA;container, with an ip within the aforementioned network range. Note&#xA;that this will happen for each host that is running Docker, without&#xA;any coordination between the hosts.  Therefore, the network ranges&#xA;might collide.&#xA;&#xA;Because of this, containers will only be able to communicate with&#xA;containers that are connected to the same virtual bridge. In order to&#xA;communicate with other containers on other hosts, they must rely on&#xA;port-mapping. This means that you need to assign a port on the host&#xA;machine to each container, and then somehow forward all traffic on&#xA;that port to that container. What if your application needs to&#xA;advertise its own IP address to a container that is hosted on another&#xA;node? It doesn’t actually knows its real IP, since his local IP is&#xA;getting translated into another IP and a port on the host machine. You&#xA;can automate the port-mapping, but things start to get kinda complex&#xA;when following this model.&#xA;&#xA;That’s why Kubernetes chose simplicity and skipped the dynamic&#xA;port-allocation deal. It just assumes that all containers can&#xA;communicate with each other without Network Address Translation (NAT),&#xA;that all containers can communicate with each node (and vice-versa),&#xA;and that the IP that a container sees for itself is the same that the&#xA;other containers see for it”&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Docker doesn’t do this. They just went nuts and decided to go crazy on the&#xA;dynamic port-forwarding part. For this, they relied heavily on the existing&#xA;Linux kernel’s networking stack. This is fairly cool, since the existing Linux&#xA;networking features are pretty mature and robust already.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does it work? Docker! Episode 1 - Swarm general architecture</title>
      <link>http://localhost:1313/blog/how-does-it-work-docker-episode-1-swarm-general-architecture/</link>
      <pubDate>Thu, 08 Jun 2017 20:19:02 +0100</pubDate>
      <guid>http://localhost:1313/blog/how-does-it-work-docker-episode-1-swarm-general-architecture/</guid>
      <description>&lt;p&gt;Hey there!&lt;/p&gt;&#xA;&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;&#xA;&lt;p&gt;I hacked another thing together, this time in order to install a highly available&#xA;Docker Swarm cluster on CoreOS (yeah, Container Linux), using Ansible.&lt;/p&gt;&#xA;&lt;p&gt;If you want to try it:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/sebiwi/docker-coreos.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd docker-coreos&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make up&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will need Ansible 2.2+, Docker, Vagrant and Molecule&lt;/p&gt;&#xA;&lt;h2 id=&#34;why&#34;&gt;Why?&lt;/h2&gt;&#xA;&lt;p&gt;Well, &lt;a href=&#34;https://sebiwi.github.io/blog/how-does-it-work-kube-1/&#34;&gt;I did the same thing with Kubernetes a while ago&lt;/a&gt;, because I wanted to test&#xA;all the different new Kubernetes features and have a local cluster to play with.&#xA;I wanted to do and have the same thing with Docker in Swarm mode. I’m also&#xA;planning on comparing both of them eventually. So I needed the whole prime&#xA;matter first: installation procedures, general architecture, networking model,&#xA;concepts and abstractions and so on.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does it work? Kubernetes! Episode 2 - Kubernetes networking</title>
      <link>http://localhost:1313/blog/how-does-it-work-kubernetes-episode-2-kubernetes-networking/</link>
      <pubDate>Fri, 17 Mar 2017 20:19:02 +0100</pubDate>
      <guid>http://localhost:1313/blog/how-does-it-work-kubernetes-episode-2-kubernetes-networking/</guid>
      <description>&lt;h2 id=&#34;i-dont-even-understand-what-the-problem-is-dude&#34;&gt;I don’t even understand what the problem is dude&lt;/h2&gt;&#xA;&lt;p&gt;Well, as I said in the previous article, communication between pods that are&#xA;hosted on different machines can be a little bit tricky. Docker will create by&#xA;default a virtual bridge called “docker0” on the host machine, and it will assign&#xA;a private network range to it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/how-does-it-work-kube/2/docker-bridge.png&#34; alt=&#34;Docker bridge&#34;&gt;{: class=&amp;ldquo;bigger-image&amp;rdquo; }&lt;/p&gt;&#xA;&lt;figcaption class=&#34;caption&#34;&gt;Super bridge (172.17.0.1/16)&lt;/figcaption&gt;&#xA;&lt;p&gt;For each container that is created, a virtual ethernet device is attached to this bridge,&#xA;which is then mapped to eth0 inside the container, with an ip within the aforementioned network range.&#xA;Note that this will happen for each host that is running Docker, without any coordination between&#xA;the hosts. Therefore, the network ranges might collide.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How does it work? Kubernetes! Episode 1 - Kubernetes general architecture</title>
      <link>http://localhost:1313/blog/how-does-it-work-kubernetes-episode-1-kubernetes-general-architecture/</link>
      <pubDate>Sat, 11 Mar 2017 20:19:02 +0100</pubDate>
      <guid>http://localhost:1313/blog/how-does-it-work-kubernetes-episode-1-kubernetes-general-architecture/</guid>
      <description>&lt;h2 id=&#34;hey-everybody&#34;&gt;Hey everybody&lt;/h2&gt;&#xA;&lt;p&gt;I hacked something together in order to create a Kubernetes cluster on CoreOS&#xA;(or Container Linux) using Vagrant and Ansible.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;If you keep reading, I&amp;rsquo;m going to talk to you about Kubernetes, etcd, CoreOS, flannel,&#xA;Calico, Infrastructure as Code and Ansible testing strategies. It&amp;rsquo;s gonna be super fun.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;The whole subject was way too long for a single article. Therefore, I’ve divided it into 5 parts.&#xA;This is episode 1, regarding the Kubernetes general architecture.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
